.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Data 3pm"
.TH Graph::Data 3pm "2003-06-17" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GD::Graph::Data \- Data set encapsulation for GD::Graph
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use GD::Graph::Data;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module encapsulates the data structure that is needed for GD::Graph
and friends. An object of this class contains a list of X values, and a
number of lists of corresponding Y values. This only really makes sense
if the Y values are numerical, but you can basically store anything.
Undefined values have a special meaning to GD::Graph, so they are
treated with care when stored.
.PP
Many of the methods of this module are intended for internal use by
GD::Graph and the module itself, and will most likely not be useful to
you. Many won't even \fIseem\fR useful to you...
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\&  use GD::Graph::Data;
\&  use GD::Graph::bars;
\&
\&  my $data = GD::Graph::Data\->new();
\&
\&  $data\->read(file => \*(Aq/data/sales.dat\*(Aq, delimiter => \*(Aq,\*(Aq);
\&  $data = $data\->copy(wanted => [2, 4, 5]);
\&
\&  # Add the newer figures from the database
\&  use DBI;
\&  # do DBI things, like connecting to the database, statement
\&  # preparation and execution
\&
\&  while (@row = $sth\->fetchrow_array)
\&  {
\&      $data\->add_point(@row);
\&  }
\&
\&  my $chart = GD::Graph::bars\->new();
\&  my $gd = $chart\->plot($data);
.Ve
.PP
or for quick changes to legacy code
.PP
.Vb 2
\&  # Legacy code builds array like this
\&  @data = ( [qw(Jan Feb Mar)], [1, 2, 3], [5, 4, 3], [6, 3, 7] );
\&
\&  # And we quickly need to do some manipulations on that
\&  my $data = GD::Graph::Data\->new();
\&  $data\->copy_from(\e@data);
\&
\&  # And now do all the new stuff that\*(Aqs wanted.
\&  while (@foo = bar_baz())
\&  {
\&      $data\->add_point(@foo);
\&  }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$data = GD::Graph::Data\->\fInew()\fP"
.el .SS "\f(CW$data\fP = GD::Graph::Data\->\fInew()\fP"
.IX Subsection "$data = GD::Graph::Data->new()"
Create a new GD::Graph::Data object.
.ie n .SS "$data\->set_x($np, $value);"
.el .SS "\f(CW$data\fP\->set_x($np, \f(CW$value\fP);"
.IX Subsection "$data->set_x($np, $value);"
Set the X value of point \fI\f(CI$np\fI\fR to \fI\f(CI$value\fI\fR. Points are numbered
starting with 0. You probably will never need this. Returns undef on
failure.
.ie n .SS "$data\->get_x($np)"
.el .SS "\f(CW$data\fP\->get_x($np)"
.IX Subsection "$data->get_x($np)"
Get the X value of point \fI\f(CI$np\fI\fR. See \*(L"set_x\*(R".
.ie n .SS "$data\->set_y($nd, $np, $value);"
.el .SS "\f(CW$data\fP\->set_y($nd, \f(CW$np\fP, \f(CW$value\fP);"
.IX Subsection "$data->set_y($nd, $np, $value);"
Set the Y value of point \fI\f(CI$np\fI\fR in data set \fI\f(CI$nd\fI\fR to \fI\f(CI$value\fI\fR. Points
are numbered starting with 0, data sets are numbered starting with 1.
You probably will never need this. Returns undef on failure.
.ie n .SS "$data\->get_y($nd, $np)"
.el .SS "\f(CW$data\fP\->get_y($nd, \f(CW$np\fP)"
.IX Subsection "$data->get_y($nd, $np)"
Get the Y value of point \fI\f(CI$np\fI\fR in data set \fI\f(CI$nd\fI\fR. See \*(L"set_y\*(R". This
will return undef on an error, but the fact that it returns undef does
not mean there was an error (since undefined values can be stored, and
therefore returned).
.ie n .SS "$data\->get_y_cumulative($nd, $np)"
.el .SS "\f(CW$data\fP\->get_y_cumulative($nd, \f(CW$np\fP)"
.IX Subsection "$data->get_y_cumulative($nd, $np)"
Get the cumulative value of point \fI\f(CI$np\fI\fR in data set<$nd>. The
cumulative value is obtained by adding all the values of the points
\&\fI\f(CI$np\fI\fR in the data sets 1 to \fI\f(CI$nd\fI\fR.
.ie n .SS "$data\->get_min_max_x"
.el .SS "\f(CW$data\fP\->get_min_max_x"
.IX Subsection "$data->get_min_max_x"
Returns a list of the minimum and maximum x value or the
empty list on failure.
.ie n .SS "$data\->get_min_max_y($nd)"
.el .SS "\f(CW$data\fP\->get_min_max_y($nd)"
.IX Subsection "$data->get_min_max_y($nd)"
Returns a list of the minimum and maximum y value in data set \f(CW$nd\fR or the
empty list on failure.
.ie n .SS "$data\->\fIget_min_max_y_all()\fP"
.el .SS "\f(CW$data\fP\->\fIget_min_max_y_all()\fP"
.IX Subsection "$data->get_min_max_y_all()"
Returns a list of the minimum and maximum y value in all data sets or the
empty list on failure.
.ie n .SS "$data\->add_point($X, $Y1, $Y2 ...)"
.el .SS "\f(CW$data\fP\->add_point($X, \f(CW$Y1\fP, \f(CW$Y2\fP ...)"
.IX Subsection "$data->add_point($X, $Y1, $Y2 ...)"
Adds a point to the data set. The base for the addition is the current
number of X values. This means that if you have a data set with the
contents
.PP
.Vb 4
\&  (X1,  X2)
\&  (Y11, Y12)
\&  (Y21)
\&  (Y31, Y32, Y33, Y34)
.Ve
.PP
a \f(CW$data\fR\->add_point(Xx, Y1x, Y2x, Y3x, Y4x) will result in
.PP
.Vb 5
\&  (X1,    X2,    Xx )
\&  (Y11,   Y12,   Y1x)
\&  (Y21,   undef, Y2x)
\&  (Y31,   Y32,   Y3x,  Y34)
\&  (undef, undef, Y4x)
.Ve
.PP
In other words: beware how you use this. As long as you make sure that
all data sets are of equal length, this method is safe to use.
.ie n .SS "$data\->\fInum_sets()\fP"
.el .SS "\f(CW$data\fP\->\fInum_sets()\fP"
.IX Subsection "$data->num_sets()"
Returns the number of data sets.
.ie n .SS "$data\->\fInum_points()\fP"
.el .SS "\f(CW$data\fP\->\fInum_points()\fP"
.IX Subsection "$data->num_points()"
In list context, returns a list with its first element the number of X
values, and the subsequent elements the number of respective Y values
for each data set. In scalar context returns the number of points
that have an X value set, i.e. the number of data sets that would result
from a call to \f(CW\*(C`make_strict\*(C'\fR.
.ie n .SS "$data\->\fIx_values()\fP"
.el .SS "\f(CW$data\fP\->\fIx_values()\fP"
.IX Subsection "$data->x_values()"
Return a list of all the X values.
.ie n .SS "$data\->y_values($nd)"
.el .SS "\f(CW$data\fP\->y_values($nd)"
.IX Subsection "$data->y_values($nd)"
Return a list of the Y values for data set \fI\f(CI$nd\fI\fR. Data sets are
numbered from 1. Returns the empty list if \f(CW$nd\fR is out of range, or if
the data set at \f(CW$nd\fR is empty.
.ie n .SS "$data\->\fIreset()\fP \s-1OR\s0 GD::Graph::Data\->\fIreset()\fP"
.el .SS "\f(CW$data\fP\->\fIreset()\fP \s-1OR\s0 GD::Graph::Data\->\fIreset()\fP"
.IX Subsection "$data->reset() OR GD::Graph::Data->reset()"
As an object method: Reset the data container, get rid of all data and
error messages. As a class method: get rid of accumulated error messages
and possible other crud.
.ie n .SS "$data\->\fImake_strict()\fP"
.el .SS "\f(CW$data\fP\->\fImake_strict()\fP"
.IX Subsection "$data->make_strict()"
Make all data set lists the same length as the X list by truncating data
sets that are too long, and filling data sets that are too short with
undef values. always returns a true value.
.ie n .SS "$data\->cumulate(preserve_undef => boolean)"
.el .SS "\f(CW$data\fP\->cumulate(preserve_undef => boolean)"
.IX Subsection "$data->cumulate(preserve_undef => boolean)"
The \fBcumulate\fR parameter will summarise the Y value sets as follows:
the first Y value list will be unchanged, the second will contain a
sum of the first and second, the third will contain the sum of first,
second and third, and so on.  Returns undef on failure.
.PP
if the argument \fIpreserve_undef\fR is set to a true value, then the sum
of exclusively undefined values will be preserved as an undefined value.
If it is not present or a false value, undef will be treated as zero.
Note that this still will leave undefined values in the first data set
alone.
.PP
Note: Any non-numerical defined Y values will be treated as 0, but you
really shouldn't be using this to store that sort of Y data.
.ie n .SS "$data\->wanted(indexes)"
.el .SS "\f(CW$data\fP\->wanted(indexes)"
.IX Subsection "$data->wanted(indexes)"
Removes all data sets except the ones in the argument list. It will also
reorder the data sets in the order given. Returns undef on failure.
.PP
To remove all data sets except the first, sixth and second, in that
order:
.PP
.Vb 1
\&  $data\->wanted(1, 6, 2) or die $data\->error;
.Ve
.ie n .SS "$data\->reverse"
.el .SS "\f(CW$data\fP\->reverse"
.IX Subsection "$data->reverse"
Reverse the order of the data sets.
.ie n .SS "$data\->copy_from($data_ref)"
.el .SS "\f(CW$data\fP\->copy_from($data_ref)"
.IX Subsection "$data->copy_from($data_ref)"
Copy an 'old' style GD::Graph data structure or another GD::Graph::Data
object into this object. This will remove the current data. Returns undef
on failure.
.ie n .SS "$data\->\fIcopy()\fP"
.el .SS "\f(CW$data\fP\->\fIcopy()\fP"
.IX Subsection "$data->copy()"
Returns a copy of the object, or undef on failure.
.ie n .SS "$data\->read(\fIarguments\fP)"
.el .SS "\f(CW$data\fP\->read(\fIarguments\fP)"
.IX Subsection "$data->read(arguments)"
Read a data set from a file. This will remove the current data. returns
undef on failure. This method uses the standard module 
Text::ParseWords to parse lines. If you don't have this for some odd
reason, don't use this method, or your program will die.
.PP
\&\fBData file format\fR: The default data file format is tab separated data
(which can be changed with the delimiter argument). Comment lines are
any lines that start with a #. In the following example I have replaced
literal tabs with <tab> for clarity
.PP
.Vb 6
\&  # This is a comment, and will be ignored
\&  Jan<tab>12<tab>24
\&  Feb<tab>13<tab>37
\&  # March is missing
\&  Mar<tab><tab>
\&  Apr<tab>9<tab>18
.Ve
.PP
Valid arguments are:
.PP
\&\fIfile\fR, mandatory. The file name of the file to read from, or a
reference to a file handle or glob.
.PP
.Vb 3
\&  $data\->read(file => \*(Aq/data/foo.dat\*(Aq) or die $data\->error;
\&  $data\->read(file => \e*DATA) or die $data\->error;
\&  $data\->read(file => $file_handle) or die $data\->error;
.Ve
.PP
\&\fIno_comment\fR, optional. Give this a true value if you don't want lines
with an initial # to be skipped.
.PP
.Vb 1
\&  $data\->read(file => \*(Aq/data/foo.dat\*(Aq, no_comment => 1);
.Ve
.PP
\&\fIdelimiter\fR, optional. A regular expression that will become the
delimiter instead of a single tab.
.PP
.Vb 2
\&  $data\->read(file => \*(Aq/data/foo.dat\*(Aq, delimiter => \*(Aq\es+\*(Aq);
\&  $data\->read(file => \*(Aq/data/foo.dat\*(Aq, delimiter => qr/\es+/);
.Ve
.ie n .SS "$data\->\fIerror()\fP \s-1OR\s0 GD::Graph::Data\->\fIerror()\fP"
.el .SS "\f(CW$data\fP\->\fIerror()\fP \s-1OR\s0 GD::Graph::Data\->\fIerror()\fP"
.IX Subsection "$data->error() OR GD::Graph::Data->error()"
Returns a list of all the errors that the current object has
accumulated. In scalar context, returns the last error. If called as a
class method it works at a class level.
.PP
This method is inherited, see GD::Graph::Error for more information.
.ie n .SS "$data\->\fIhas_error()\fP \s-1OR\s0 GD::Graph::Data\->\fIhas_error()\fP"
.el .SS "\f(CW$data\fP\->\fIhas_error()\fP \s-1OR\s0 GD::Graph::Data\->\fIhas_error()\fP"
.IX Subsection "$data->has_error() OR GD::Graph::Data->has_error()"
Returns true if the object (or class) has errors pending, false if not.
In some cases (see \*(L"copy\*(R") this is the best way to check for errors.
.PP
This method is inherited, see GD::Graph::Error for more information.
.SH "NOTES"
.IX Header "NOTES"
As with all Modules for Perl: Please stick to using the interface. If
you try to fiddle too much with knowledge of the internals of this
module, you could get burned. I may change them at any time.
Specifically, I probably won't always keep this implemented as an array
reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martien Verbruggen <mgjv@tradingpost.com.au>
.SS "Copyright"
.IX Subsection "Copyright"
(c) Martien Verbruggen.
.PP
All rights reserved. This package is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
GD::Graph, GD::Graph::Error
